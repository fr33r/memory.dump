## Quotes

A gathering of some of the artifacts from Domain-Driven Design that resonated with me the most.

> A model is a simplification. It is an interpretation of reality that abstracts the aspects relevant to solving the problem at hand and ignores extraneous detail. **- Pg. 2**

<!-- -->

> Every software program relates to some activity or interest of its user. That subject area to which the user applies the program is the _domain_ of the software. **- Pg. 2**

<!-- -->

> In the old waterfall method, the business experts talk to the analysts, and analysts digest and abstract and pass the result along to the programmers, who code the software. This approach fails because it completely lacks feedback. The analysts have full responsibility for creating the model, based only on input from the business experts. They have no opportunity to learn from the programmers or gain experience with early versions of software. Knowledge trickles in one direction, but does not accumulate. **- Pg. 14**

<!-- -->

> A voyage of discovery has to start somewhere. **- Pg. 16**

<!-- -->

> It is with this move beyond entities and values that knowledge crunching can get intense, because there may be actual inconsistency among business rules. Domain experts are usually not aware of how complex their mental processes are, in the course of their work, they navigate all these rules, reconcile contradictions, and fill in gaps with common sense. Software can't do this. It is through knowledge crunching in close collaboration with software experts that the rules are clarified, fleshed out, reconciled, or placed out of scope. **- Pg. 17**

<!-- -->

> If sophisticated domain experts don't understand the model, there is something wrong with the model. ** - Pg. 33**

<!-- -->

> When domain experts use this language in discussions with developers or amongst themselves, they quickly discover areas where the model is inadequate for their needs or seems wrong to them. The domain experts (with the help of the developers) will also find areas where the precision  of the model-based language exposes contradictions or vagueness in their thinking. **- Pg. 33**

<!-- -->

> Simple, informal UML diagrams can anchor a discussion. Sketch a diagram of three to five objects central to the issue at hand, and everyone can stay focused. Everyone will share a view of the relationship between the objects and, significantly, the objects' names. The spoken discussion can be more effective with this aid. **- Pg. 35**

<!-- -->

> The trouble comes when people feel compelled to convey the whole model or design through UML. A lot of object model diagrams are too complete and, simultaneously, leave too much out They are too complete because people feel they have to put all the objects that they are going to code into a modeling tool. With all that detail, no one can see the forest for the trees. **- Pg. 35**

<!-- -->

> Diagrams are a means for communication and explanation, and they facilitate brainstorming. They serve these ends best if they are minimal. Comprehensive diagrams of the entire object model fail to communicate or explain; they overwhelm the reader with detail and they lack meaning. **- Pg. 36**

<!-- -->

> Always remember that the model is not the diagram. The diagram's purpose is to help communicate and explain the model. The code can serve as a repository of the details of the design. **- Pg. 37**

<!-- -->

> A document shouldn't try to do what the code already does well. The code already supplies the detail. It is an exact specification of program behavior. **- Pg. 38**

<!-- -->

> When I document a model in writing, I diagram small, carefully selected subsets of the model and surround them with text. I define the classes and their responsibilities in words and frame them in a context of meaning as only a natural language can. **- Pg. 38**

<!-- -->

> The greatest values of a design document is to explain the concepts of the model, help in navigating the detail of the code and perhaps give some insight into the model's intended style of use. Depending on the philosophy of the team, the whole design document could be as simple as a set of sketches posted on the walls, or it could be substantial. **- Pg. 39**

<!-- -->

> A document must be involved in project activities. The easiest way to judge this is to observe the document's interaction with the ubiquitous language. Is the document written int he language people speak on the project (now)? Is it written in the language embedded in the code? **- Pg. 39**

<!-- -->

> Well-written code can be very communicative, but the message it communicates is not guaranteed to be accurate. Oh, the reality of the *behavior* caused by a section of code is inescapable. But a method name can be ambiguous, misleading, or out of date compared to the internals of the method. The assertions in a test are rigorous, but the story told by variable names and the organization of the code is not. Good programming style keeps this connection as direct as possible, but it is still an exercise in self-discipline. It takes fastidiousness to write code that doesn't just *do* the right thing but also *says* the right thing. **- Pg. 40**

<!-- -->

> Quietly changing data is completely unacceptable in most applications. **- Pg. 58**

<!-- -->

> When a design is based on a model that reflect the basic concerns of the users and domain experts, the bones of the design can be revealed to the user to a greater extent than with other design approaches. Revealing the model gives the user more access to the potential of the software and yields consistent, predictable behavior. **- Pg. 59**

<!-- -->

> Manufacturing is a popular metaphor for software development. One inference from this metaphor: highly skilled engineers design; less skilled laborers assemble the products. This metaphor has messed up a lot of projects for one simple reason--software development is *all* design. **- Pg. 60**

<!-- -->

> The need for hands-on modelers does not mean that team members cannot have specialized roles. Every Agile process, including Extreme Programming, defines roles for team members, and other informal specializations tend to emerge naturally. The problem arises from separating two tasks that are coupled in a model-driven design, modeling and implementation. **- Pg. 61**

<!-- -->

> Anyone responsible for changing code must learn to express a model through the code. Every developer must be involved in some level of discussion about the model and have contact with domain experts. Those who contribute in different ways must consciously engage those who touch the code in a dynamic exchange of model ideas through the ubiquitous language.
